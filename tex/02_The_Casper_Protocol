\section{Casper プロトコル}

Ethereum内では、提案メカニズムは最初に既存のProof of Work チェーンとなり、Casperの最初のバージョンをPoW/PoSのハイブリットシステムにしました。
将来のバージョンでは、PoWによる提案の仕組みはより効率的なものに置き換えられます。
例えば、ブロック提案をある種のPoSラウンドロビンブロック署名方式に変換すると想像できます。\\*

このシンプルなバージョンのCasperでは、固定されたバリデーターセットと提案メカニズム（例えば、おなじみのProof of Work提案メカニズム）があると仮定して、既存のブロックの子ブロックを生成し、常に成長するブロックツリーを形成します。
[6]から、ツリーの根は一般に「ジェネシスブロック」と呼ばれています。\\*

通常の状況下では、提案メカニズムは、リンクされたリストにおいて順番にブロックを次々に提案することを期待します (すなわち、各「親」ブロックがちょうど1つの「子」ブロックを有する)。
しかし、ネットワークの待ち時間や意図的な攻撃があった場合、提案メカニズムは必然的に同じ親の複数の子を必然的に生成することになります。
Casperの仕事は、各親から1人の子供を選択し、ブロックツリーから1つの正規のチェーンを選択することです。\\*

フルブロックツリーを扱うのではなく、効率を上げるために、Casperはチェックポイントツリーを構成するチェックポイントのサブツリーのみを考慮します (図 1a) 。
ジェネシスブロックはチェックポイントであり、ブロックツリー (またはブロック番号) の高さが100の倍数である全てのブロックもチェックポイントです。
ブロックの高さ100*k ブロックの「チェックポイントの高さ」は単純にkです。
等価的に、チェックポイントcの高さh(c)は、親リンクに沿ってルートからルート(c)まで伸びるチェックポイントチェーンの要素の数です (図 1b) 。\\*


各バリデーターはデポジットを持っています。これはバリデーターとして参加する時の、コインの数です。
参加後、各バリデータのデポジットは報酬と罰則に伴って昇降します。Proof of Stake の安全性は、バリデーターの数ではなく、デポジットのサイズに由来します。
したがって、本書の残りの部分では、「バリデーター2/3」と言う場合、これはデポジットの加重割合を指しています。
つまり、合計のデポジットサイズがバリデーターセット全体のデポジットサイズの2/3に等しいバリデーターセットだということです。\\*


バリデーターは4つの情報 (表1) である：2つのチェックポイント s および t と、高さ h(s) および h(t) を含む投票メッセージをブロードキャストすることができます。
チェックポイントツリーでは s が t の祖先であることが必要です。
そうでなければ、投票は無効と見なされます。
バリデーターvの公開鍵がバリデーターセットにない場合、投票は無効と見なされます。
併せて、バリデーターの署名と共に、これらの投票を ⟨v, s, t, h(s), h(t)⟩ の形で書く。\\*


我々は以下の用語を定義する。

\begin{itemize}
  \item Supermajority link は、少なくとも 2/3 のバリデーター（デポジットによる）がソースaとターゲットbとで投票を公開するように、a→bと書かれたチェックポイントの順序付きペア（a, b）です。Supermajority links はチェックポイントをスキップすることができます。つまり、h(b)> h(a)+1です。図1cは、赤の3つの異なるSupermajority links を示しています：r→b1, b1→b2, そして b2→b3。
  \item 2つのチェックポイント a と bは、それらが別々のブランチ内のノードである場合、すなわち祖先または他方の子孫のいずれでもない場合にのみ、矛盾すると呼ばれる。
  \item チェックポイント c は、(1) ルートである場合にjustifiedされ、(2) c’ がjustifiedされるsupermajority link c’→c が存在する場合、図1cは、4つの justified ブロックのチェーンを示しています。
  \item チェックポイント c は、finalizedされ、supermajority link c→c' があり、c' が c の直接の子である場合、finalizedされます。同様に、チェックポイントcは、チェックポイント c がjustifiedされ、 supermajority link c→c' が存在し、チェックポイント c と c' が衝突していない場合にのみ終了し、h(c') = h(c)+1である。
\end{itemize}

これらのルールのいずれかに違反したバリデーターは、デポジットを払い落とし(slashed)ます。

Casperの最も注目すべき特性は、バリデーターの1/3が2つのCasper Commandments/slashing conditions の内1つに違反し、2つの矛盾するチェックポイントをfinalizeすることが不可能であることです。(図2)

バリデーターが slashing conditionに違反した場合、違反の証拠をトランザクションとしてブロックチェーンに組み込むことができます。その時点で、証拠トランザクションの提出者に与えられた小さな ”ファインダー報酬” が付いています。現在のEthereumでは、slashing conditionを強制停止するには、EthereumのProof of Workブロック提案者に51％の攻撃を成功させる必要があります。

\subsection{安全性とその可能性の証明}

私たちは、Casperの2つの基本的な特性、すなわち、accountable safety と d plausible liveness を証明しています。
Accountable safetyとは1/3が Slashing condition に違反しない限り(つまり、デポジット総額の少なくとも3分の1が失われていることを意味します)、2つの競合するチェックポイントをfinalize することはできません。
Plausible livenessとは、以前の出来事 (例えば、スラッシングイベント、遅延ブロック、検閲攻撃など) に関係なく、バリデータの2/3以上がプロトコルに従うならば、バリデータを違反することなく常に新しいチェックポイントをfinalizeすることができることを意味する、Slashing conditionのことです。


バリデーターの2/3が軽度のSlashing conditionに違反していないという前提の下で、我々は以下の特性を有します:

\begin{itemize}
  \item If s1 → t1 and s2 → t2 are distinct supermajority links, then h(t1) 6= h(t2).
  \item s1→t1とs2→t2が異なる超大多数のリンクである場合、不等式h(s1) <h(s2)<h(t2) <h(t1)は成り立たない。

  これらの2つの特性から、任意の高さnに対して、

  \item h(t) = nで最大でも1つの超大多数のリンクs→tが存在する。
  \item 高さnの正当化されたチェックポイントが最大でも1つ存在する。
\end{itemize}

この4つの特性を手にして、Main theoremsに移ります。

\begin{description}
  \item[Theorem 1] (Accountable Safety). 2つの競合するチェックポイントamとbnの両方を確定することはできません。
  \item[Theorem 2] (Plausible Liveness). 完成したチェーンを拡張する子が存在する場合は、新しい大域チェックポイントを生成するために、Supermajority linksを常に追加することができます。
\end{description}

\subsection{Casperのフォーク選択ルール}

Casperは標準のPoW設計よりも複雑です。そのため、フォークの選択を調整する必要があります。変更されたフォーク選択ルールの後には、すべてのユーザー、バリデーター、さらには基礎となるブロックの提案メカニズムが必要です。
ユーザ、バリデーター、またはブロック提案者の代わりに、 "常に最長のチェーン上に構築する" という標準のPoWフォーク選択ルールに従うと、Casperが “stuck” し、最長チェーンの上に構築されたブロックを finalize できない (もしくは justifiedされていても ) 一部のバリデータが利他的にそのデポジットを犠牲にすることはありません。
これを避けるために、私たちは小説 Correct by Construction のフォーク選択ルールを紹介します：FOLLOW THE CHAIN CONTAINING THE JUSTIFIED CHECKPOINT OF THE GREATEST HEIGHT。
このフォーク選択ルールは、Correct by Constructionです。なぜなら、Plausible Livenessの証明(Theorem 2)から導かれるからです。
最大の高さを持つ justifiedなチェックポイントの上に新しいチェックポイントを常に finalize することが常に可能であると正確に述べています。
このフォーク選択ルールは、セクション3と4で調整されます。
